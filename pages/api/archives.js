export default function handler(req, res) {
  res.status(200).json({
    2022: {
      April: [
        {
          id: '70efa1fc-0454-4db8-99ef-72ccd47cd445',
          title: '数据可视化',
          cover:
            'https://wipi.oss-cn-shanghai.aliyuncs.com/2020-04-04/transformation-3746922_1280.jpg',
          summary: '数据可视化的主要任务是将数据转换为易于感知的图形。',
          content:
            '# 数据可视化\r\n\r\n数据可视化的主要任务是将数据转换为易于感知的图形。',
          html: '<h2 id="安装-docker">数据可视化</h2>\n<p>在网站下载安装 Docker 。 安装完成后，打开命令行输入 <code>docker version</code>，如果有相关输出即安装成功。</p>\n<h2 id="运行-container">运行 container</h2>\n<p>docker 中与 <code>container</code> 相关的命令主要有：</p>\n<ul>\n<li><code>docker container run ...</code>：运行容器</li>\n<li><code>docker container ls</code>: 列出当前运行容器</li>\n<li><code>docker container start [container_id | container_name]</code>: 开始运行指定 id（或名称） 的容器</li>\n<li><code>docker container stop [container_id | container_name]</code>: 停止运行指定 id（或名称） 的容器</li>\n<li><code>docker container rm [container_id| container_name]</code>: 删除指定 id（或名称） 的容器</li>\n</ul>\n<p>其中，也可以使用 <code>docker ps</code> 查看正在运行的容器。</p>\n<h3 id="运行-nginx">运行 nginx</h3>\n<p>打开命令行，键入：</p>\n<pre><code>docker container run -it -p 8080:81 nginx\n</code></pre>\n<p>如果报错无法拉取，执行 <code>docker login</code> 输入账号密码登录 docker hub 账号后再执行。 在浏览器访问网站：<code>http://localhost:8080</code>，如果可以访问到 nginx 相关即表示运行成功。</p>\n<p><code>-p 8080:81</code> 指定镜像在容器内运行的端口为：<code>81</code>，同时将端口映射到本地机器的 <code>8080</code> 端口，所以需要在浏览器访问 <code>http://localhost:8080</code> 才可。</p>\n<h3 id="运行-mysql">运行 mysql</h3>\n<p>不同与 nginx ，运行 mysql 时可能需要设置一些变量，比如数据库密码之类的，这就需要用到 <code>--env</code> 参数。</p>\n<pre><code>docker container run -d -p 3006:3036 --env MYSQL_ROOT_PASSWORD=123456 mysql\n</code></pre>\n<h2 id="进入-container">进入 container</h2>\n<p>使用 <code>docker container -it exec [container_id | container_name]</code> 可以运行指定的容器内的程序</p>\n<p>首先，运行一个名为 <code>mynginx</code> 的容器。</p>',
          toc: '[{"level":"1","id":"数据可视化","text":"数据可视化"},{"level":"2","id":"一、可视化流程","text":"一、可视化流程"},{"level":"3","id":"通用的可视化流程","text":"通用的可视化流程"},{"level":"3","id":"1-分析","text":"1. 分析"},{"level":"3","id":"2-处理","text":"2. 处理"},{"level":"3","id":"3-生成","text":"3. 生成"},{"level":"2","id":"二、数据模型","text":"二、数据模型"},{"level":"3","id":"1-数据模型与概念模型","text":"1. 数据模型与概念模型"},{"level":"3","id":"2-数据类型","text":"2. 数据类型"},{"level":"3","id":"3-举个例子","text":"3. 举个例子"},{"level":"2","id":"三、视觉编码","text":"三、视觉编码"},{"level":"3","id":"1-什么是视觉编码？","text":"1. 什么是视觉编码？"},{"level":"3","id":"2-常用的视觉通道","text":"2. 常用的视觉通道"},{"level":"3","id":"3-视觉编码设计原则","text":"3. 视觉编码设计原则"},{"level":"2","id":"参考文献","text":"参考文献"}]',
          status: 'publish',
          views: 1249,
          likes: 13,
          isRecommended: false,
          needPassword: false,
          isCommentable: true,
          publishAt: '2022-04-12T01:18:25.000Z',
          createAt: '2020-04-05T08:30:04.529Z',
          updateAt: '2022-05-10T06:29:49.000Z',
        },
        {
          id: '7b1d5c29-bffb-4bab-be7b-855f81825c76',
          title: 'Docker 使用笔记（一）',
          cover:
            'https://wipi.oss-cn-shanghai.aliyuncs.com/2020-02-10/TBRGIVFYPEAWW7M0AM6TDG/16410734eb1ed373.png',
          summary: 'Docker 使用笔记系列第一篇。',
          content:
            '## 安装 Docker\n\n\n在 [Docker](https://www.docker.com/get-started) 网站下载安装 Docker 。 安装完成后，打开命令行输入 `docker version`，如果有相关输出即安装成功。\n\n## 运行 container\n\n\ndocker 中与 `container` 相关的命令主要有：\n\n*   `docker container run ...`：运行容器\n*   `docker container ls`: 列出当前运行容器\n*   `docker container start [container_id | container_name]`: 开始运行指定 id（或名称） 的容器\n*   `docker container stop [container_id | container_name]`: 停止运行指定 id（或名称） 的容器\n*   `docker container rm [container_id| container_name]`: 删除指定 id（或名称） 的容器\n\n其中，也可以使用 `docker ps` 查看正在运行的容器。\n\n### 运行 nginx\n\n打开命令行，键入：\n\n    docker container run -it -p 8080:81 nginx\n    \n\n如果报错无法拉取，执行 `docker login` 输入账号密码登录 docker hub 账号后再执行。 在浏览器访问网站：`http://localhost:8080`，如果可以访问到 nginx 相关即表示运行成功。\n\n`-p 8080:81` 指定镜像在容器内运行的端口为：`81`，同时将端口映射到本地机器的 `8080` 端口，所以需要在浏览器访问 `http://localhost:8080` 才可。\n\n### 运行 mysql\n\n不同与 nginx ，运行 mysql 时可能需要设置一些变量，比如数据库密码之类的，这就需要用到 `--env` 参数。\n\n    docker container run -d -p 3006:3036 --env MYSQL_ROOT_PASSWORD=123456 mysql\n    \n\n## 进入 container\n\n\n使用 `docker container -it exec [container_id | container_name]` 可以运行指定的容器内的程序\n\n首先，运行一个名为 `mynginx` 的容器：\n\n    docker container run -d -p 8080:80 --name mynginx nginx\n    \n\n然后，调用 `mynginx` 的 `bash` 程序：\n\n    docker container exec -it mynginx bash\n    \n\n如此，便可以在 container 内部操作环境执行命令，就像是进入了这个 container 操作环境内一样。\n\n### 绑定挂载点\n\n\n在上一步中，可以知道 container mynginx 的文件路径为：`/usr/share/nginx/html`。如果想要修改这些文件，就需要进入 container 内部进行修改，这样便会很麻烦。docker 提供了绑定挂载点的功能，这样便可以把本地机器的文件映射到 container 内部。\n\n    docker container run -d -p 8080:81 -v ~/test:/usr/share/nginx/html --nmae mynginx nginx\n    \n\n在本地机器的 test 文件夹，新建一个 index.html 文件，然后浏览器访问 `http://localhost:8080`，便可以看到刚刚保存的内容。\n\n### 制作镜像\n\n\n`docker container run` 的过程是首先拉取镜像，然后运行这个镜像。如此便可以制作自己的镜像。例如：\n\n首先新建一个文件夹，然后新建一个 `index.html` 文件并写入内容，然后再编写 `Dockerfile` 文件。\n\n    FROM nginx:latest\n    \n    WORKDIR /usr/share/nginx/html\n    \n    COPY . .\n    \n\n然后运行 `docker image build . -t mynginx-web`（`.` 是指当前路径），便完成了镜像制作。\n\n运行这个镜像只需要：`docker container run -it -p 8080:80 mynginx-web`。',
          html: '<h2 id="安装-docker">安装 Docker</h2>\n<p>在网站下载安装 Docker 。 安装完成后，打开命令行输入 <code>docker version</code>，如果有相关输出即安装成功。</p>\n<h2 id="运行-container">运行 container</h2>\n<p>docker 中与 <code>container</code> 相关的命令主要有：</p>\n<ul>\n<li><code>docker container run ...</code>：运行容器</li>\n<li><code>docker container ls</code>: 列出当前运行容器</li>\n<li><code>docker container start [container_id | container_name]</code>: 开始运行指定 id（或名称） 的容器</li>\n<li><code>docker container stop [container_id | container_name]</code>: 停止运行指定 id（或名称） 的容器</li>\n<li><code>docker container rm [container_id| container_name]</code>: 删除指定 id（或名称） 的容器</li>\n</ul>\n<p>其中，也可以使用 <code>docker ps</code> 查看正在运行的容器。</p>\n<h3 id="运行-nginx">运行 nginx</h3>\n<p>打开命令行，键入：</p>\n<pre><code>docker container run -it -p 8080:81 nginx\n</code></pre>\n<p>如果报错无法拉取，执行 <code>docker login</code> 输入账号密码登录 docker hub 账号后再执行。 在浏览器访问网站：<code>http://localhost:8080</code>，如果可以访问到 nginx 相关即表示运行成功。</p>\n<p><code>-p 8080:81</code> 指定镜像在容器内运行的端口为：<code>81</code>，同时将端口映射到本地机器的 <code>8080</code> 端口，所以需要在浏览器访问 <code>http://localhost:8080</code> 才可。</p>\n<h3 id="运行-mysql">运行 mysql</h3>\n<p>不同与 nginx ，运行 mysql 时可能需要设置一些变量，比如数据库密码之类的，这就需要用到 <code>--env</code> 参数。</p>\n<pre><code>docker container run -d -p 3006:3036 --env MYSQL_ROOT_PASSWORD=123456 mysql\n</code></pre>\n<h2 id="进入-container">进入 container</h2>\n<p>使用 <code>docker container -it exec [container_id | container_name]</code> 可以运行指定的容器内的程序</p>\n<p>首先，运行一个名为 <code>mynginx</code> 的容器。</p>',
          toc: '[{"level":"2","id":"安装-docker","text":"安装 Docker"},{"level":"2","id":"运行-container","text":"运行 container"},{"level":"3","id":"运行-nginx","text":"运行 nginx"},{"level":"3","id":"运行-mysql","text":"运行 mysql"},{"level":"2","id":"进入-container","text":"进入 container"},{"level":"3","id":"绑定挂载点","text":"绑定挂载点"},{"level":"3","id":"制作镜像","text":"制作镜像"}]',
          status: 'publish',
          views: 726,
          likes: 9,
          isRecommended: false,
          needPassword: false,
          isCommentable: true,
          publishAt: '2022-04-12T01:18:25.000Z',
          createAt: '2020-04-05T08:30:04.529Z',
          updateAt: '2022-05-10T06:30:46.000Z',
        },
        {
          id: '643d7a1a-781d-4e34-ac4b-629e103a4721',
          title: '使用 preact 优化 next.js 构建体积',
          cover:
            'https://wipi.oss-cn-shanghai.aliyuncs.com/2021-10-07/1_dvRAmbILRRbAa6HIUZkvfA.png',
          summary: '在生产环境打包时，使用 preact 替代 react 优化构建体积。',
          content:
            "对于 `next.js` 应用，生产环境打包时，可以使用 `preact` 替代 `react` 来优化构建体积。在 `next.config.js` 添加配置：\n\n```js\nwebpack: (config, { dev, isServer }) => {\n    if (!dev && !isServer) {\n      Object.assign(config.resolve.alias, {\n        'react': 'preact/compat',\n        'react-dom/test-utils': 'preact/test-utils',\n        'react-dom': 'preact/compat',\n      });\n    }\n\n    return config;\n}\n```\n\n1. 使用 `preact`\n\n![preact.jpg](https://wipi.oss-cn-shanghai.aliyuncs.com/2021-10-07/GMCBF3SDVE41GYA0A1BXHT/preact.jpg)\n\n2. 使用 `react`\n\n![react.jpg](https://wipi.oss-cn-shanghai.aliyuncs.com/2021-10-07/GMCBF3SDVE41GYA0A1BXQC/react.jpg)\n\n\n对于本站，大约可以缩减 `32KB` 的体积。\n",
          html: '<p>对于 <code>next.js</code> 应用，生产环境打包时，可以使用 <code>preact</code> 替代 <code>react</code> 来优化构建体积。在 <code>next.config.js</code> 添加配置：</p>\n<pre><code class="js language-js">webpack: (config, { dev, isServer }) =&gt; {\n    if (!dev &amp;&amp; !isServer) {\n      Object.assign(config.resolve.alias, {\n        \'react\': \'preact/compat\',\n        \'react-dom/test-utils\': \'preact/test-utils\',\n        \'react-dom\': \'preact/compat\',\n      });\n    }\n\n    return config;\n}\n</code></pre>\n<ol>\n<li>使用 <code>preact</code></li>\n</ol>\n<p><img src="https://wipi.oss-cn-shanghai.aliyuncs.com/2021-10-07/GMCBF3SDVE41GYA0A1BXHT/preact.jpg" alt="preact.jpg" /></p>\n<ol start="2">\n<li>使用 <code>react</code></li>\n</ol>\n<p><img src="https://wipi.oss-cn-shanghai.aliyuncs.com/2021-10-07/GMCBF3SDVE41GYA0A1BXQC/react.jpg" alt="react.jpg" /></p>\n<p>对于本站，大约可以缩减 <code>32KB</code> 的体积。</p>',
          toc: '[]',
          status: 'publish',
          views: 1628,
          likes: 45,
          isRecommended: false,
          needPassword: false,
          isCommentable: true,
          publishAt: '2022-04-12T01:17:45.000Z',
          createAt: '2021-10-07T06:32:17.814Z',
          updateAt: '2022-05-10T06:00:14.000Z',
        },
        {
          id: '6f8b87c5-f2bf-4ae5-b4c3-9a9991463740',
          title: '写在工作 3 年',
          cover:
            'https://wipi.oss-cn-shanghai.aliyuncs.com/2020-04-04/code-2620118_1280.jpg',
          summary:
            '时间总是过得飞快，从 18 年到 21 年，转眼就工作 3 年了。按照阿里 1 年新、3 年醇、5 年陈的说法，提笔写一下 3 年的感受。',
          content:
            '## 一、关于工作\n\n### 1. 工作是什么\n\n刚实习的时候，想的很简单--希望将来工作可以月薪过万。如今还是并不快乐，也许是因为钱不够，也许是认识到在一定阶段内，个人能力所能得到回报就是这些，这样就会想一些其他的“虚”的。\n\n子曰．“君子不器。”世界不会因平凡而变得精彩，与其平平淡淡地活着，不如多做多看，也许能做出一番自己的贡献。现在有很多人嘲笑说，互联网公司只会从小商小贩嘴里抢食，永远都是在做**模式创新**，而不是硬核的**科技创新**。但是我相信**外卖**也好、**买菜**也好，一定程度上是驱动了社会进步的，每个公司的使命是不一样的，也是能够为人民的生活带来美好的。\n\n所以工作也好，生活也好，对个人来说：\n\n1. 不断地自我塑造，打造“自己”这个产品\n2. 不断地驱动自我进步，努力实现自我价值\n\n### 2. 作为工程师\n\n也许工程师本质上就是计算机，而计算机的组成部分，只有 4 个：**输入信息、存储信息、处理信息、输出信息**。业务本身是多变的，做什么其实不重要，作为工程师，要能够把在业务中所遇到的“业务难题、复杂链路、技术难点”等抽象，作为自己成长的养料，让自己这台计算机持续学习，持续优化。\n\n### 3. 作为团队成员\n\n团队，本质上构建了一个计算集群，而我们就是其中一个计算节点。对于团队来说，个人积极地完成输出就是最大的贡献，这个输出应当包含：学习、沉淀、分享、负责和影响。努力做最好的自己，认真生活，快乐工作，分享传播，和伙伴们共同进步。\n\n## 二、关于成长\n\n### 1. 永存的困惑\n\n毫不夸张地说，这 3 年我没有不困惑的时候。面对困惑，我只能不断寻找答案，不断提升自己的认知，多读书，多看前辈的思考（计算机系列图书，大多都会写到**站在巨人的肩膀上**），去探知困惑的本质。这也许是一个漫长的过程，这时候可能就需要找点事干，比如看点代码、写点代码，让自己安静下来。\n\n### 2. 历史与现实\n\n从古至今很多事情本质上是没有变化的，历史的经验还是很有现实指导意义的。世界不是表面上那么简单的，不仅仅只是黑白对立面，好与坏而已，要辩证地去看待。历朝历代，风气云涌，都是摸着石头过河，都是不断探索，艰难前行，在这个历程中要接受现实，不断调整，不要忘了初心即可。\n\n### 3. 发展与未来\n\n对于个体来说，永远要把自我提升作为第一位。阿里常说，今天最好的表现，是明天最低的要求（听着有些 PUA）,自我整体上还是需要不断超越的，要找到自己成长的方法。对我来说，整体上还是分为：**硬技能** 和 **软技能**。\n\n#### 3.1 硬技能\n\n对于**硬技能**，就是自身的技术实力，整体上的规划还是以下方面的持续学习。\n\n- 操作系统\n- 计算机网络\n- 计算机组成原理\n- 数据结构与算法\n- 数据库系统（MySQL、MonogoDB 等）\n- 编程语言的学习与精进\n- Devops\n\n#### 3.2 软技能\n\n做事的永远是人，人与人之间是要沟通合作的。为了达到良好的沟通合作效果，需要个体具备：抽象能力、沟通能力、演讲能力、协作能力等。对此，我目前的感悟不多，也是在不断学习。\n\n## 三、关于价值观\n\n现在各行各业都很卷，年轻人们貌似也很难受（卷也是年轻人在卷，矛盾🐱），但是又好像无解，我认为这是价值观的原因。价值观是一种精神力量，一定程度上影响了我们如何看待事物、如何做事。\n\n从国家到个人，组织到个人，团队到个人，无外乎都有文化价值观这种东西，比如实现中华民族伟大复兴，满足人民对美好生活的向往。我相信每一个人都是向往美好生活的，但是做事要付出代价的，为了美好生活，是需要付出努力的（而且努力不一定有结果），所以需要文化价值观这一精神力量来驱动个体前进。文化价值观本身没有错，做事的是人，你怎么做，和你最后获得什么样的结果，一定是有关系的。\n\n阿里对员工的要求是：**聪明、自省、乐观、皮实**，同时也需要我们具备三个主义：**理想主义、现实主义、乐观主义**。遇到一些难受的事情，可以多想想应该用怎样的价值观去对待。\n\n愿我们都能够，**面对现实，勇敢追求**。\n',
          html: '<h2 id="一、关于工作">一、关于工作</h2>\n<h3 id="1-工作是什么">1. 工作是什么</h3>\n<p>刚实习的时候，想的很简单--希望将来工作可以月薪过万。如今还是并不快乐，也许是因为钱不够，也许是认识到在一定阶段内，个人能力所能得到回报就是这些，这样就会想一些其他的“虚”的。</p>\n<p>子曰．“君子不器。”世界不会因平凡而变得精彩，与其平平淡淡地活着，不如多做多看，也许能做出一番自己的贡献。现在有很多人嘲笑说，互联网公司只会从小商小贩嘴里抢食，永远都是在做<strong>模式创新</strong>，而不是硬核的<strong>科技创新</strong>。但是我相信<strong>外卖</strong>也好、<strong>买菜</strong>也好，一定程度上是驱动了社会进步的，每个公司的使命是不一样的，也是能够为人民的生活带来美好的。</p>\n<p>所以工作也好，生活也好，对个人来说：</p>\n<ol>\n<li>不断地自我塑造，打造“自己”这个产品</li>\n<li>不断地驱动自我进步，努力实现自我价值</li>\n</ol>\n<h3 id="2-作为工程师">2. 作为工程师</h3>\n<p>也许工程师本质上就是计算机，而计算机的组成部分，只有 4 个：<strong>输入信息、存储信息、处理信息、输出信息</strong>。业务本身是多变的，做什么其实不重要，作为工程师，要能够把在业务中所遇到的“业务难题、复杂链路、技术难点”等抽象，作为自己成长的养料，让自己这台计算机持续学习，持续优化。</p>\n<h3 id="3-作为团队成员">3. 作为团队成员</h3>\n<p>团队，本质上构建了一个计算集群，而我们就是其中一个计算节点。对于团队来说，个人积极地完成输出就是最大的贡献，这个输出应当包含：学习、沉淀、分享、负责和影响。努力做最好的自己，认真生活，快乐工作，分享传播，和伙伴们共同进步。</p>\n<h2 id="二、关于成长">二、关于成长</h2>\n<h3 id="1-永存的困惑">1. 永存的困惑</h3>\n<p>毫不夸张地说，这 3 年我没有不困惑的时候。面对困惑，我只能不断寻找答案，不断提升自己的认知，多读书，多看前辈的思考（计算机系列图书，大多都会写到<strong>站在巨人的肩膀上</strong>），去探知困惑的本质。这也许是一个漫长的过程，这时候可能就需要找点事干，比如看点代码、写点代码，让自己安静下来。</p>\n<h3 id="2-历史与现实">2. 历史与现实</h3>\n<p>从古至今很多事情本质上是没有变化的，历史的经验还是很有现实指导意义的。世界不是表面上那么简单的，不仅仅只是黑白对立面，好与坏而已，要辩证地去看待。历朝历代，风气云涌，都是摸着石头过河，都是不断探索，艰难前行，在这个历程中要接受现实，不断调整，不要忘了初心即可。</p>\n<h3 id="3-发展与未来">3. 发展与未来</h3>\n<p>对于个体来说，永远要把自我提升作为第一位。阿里常说，今天最好的表现，是明天最低的要求（听着有些 PUA）,自我整体上还是需要不断超越的，要找到自己成长的方法。对我来说，整体上还是分为：<strong>硬技能</strong> 和 <strong>软技能</strong>。</p>\n<h4 id="31-硬技能">3.1 硬技能</h4>\n<p>对于<strong>硬技能</strong>，就是自身的技术实力，整体上的规划还是以下方面的持续学习。</p>\n<ul>\n<li>操作系统</li>\n<li>计算机网络</li>\n<li>计算机组成原理</li>\n<li>数据结构与算法</li>\n<li>数据库系统（MySQL、MonogoDB 等）</li>\n<li>编程语言的学习与精进</li>\n<li>Devops</li>\n</ul>\n<h4 id="32-软技能">3.2 软技能</h4>\n<p>做事的永远是人，人与人之间是要沟通合作的。为了达到良好的沟通合作效果，需要个体具备：抽象能力、沟通能力、演讲能力、协作能力等。对此，我目前的感悟不多，也是在不断学习。</p>\n<h2 id="三、关于价值观">三、关于价值观</h2>\n<p>现在各行各业都很卷，年轻人们貌似也很难受（卷也是年轻人在卷，矛盾🐱），但是又好像无解，我认为这是价值观的原因。价值观是一种精神力量，一定程度上影响了我们如何看待事物、如何做事。</p>\n<p>从国家到个人，组织到个人，团队到个人，无外乎都有文化价值观这种东西，比如实现中华民族伟大复兴，满足人民对美好生活的向往。我相信每一个人都是向往美好生活的，但是做事要付出代价的，为了美好生活，是需要付出努力的（而且努力不一定有结果），所以需要文化价值观这一精神力量来驱动个体前进。文化价值观本身没有错，做事的是人，你怎么做，和你最后获得什么样的结果，一定是有关系的。</p>\n<p>阿里对员工的要求是：<strong>聪明、自省、乐观、皮实</strong>，同时也需要我们具备三个主义：<strong>理想主义、现实主义、乐观主义</strong>。遇到一些难受的事情，可以多想想应该用怎样的价值观去对待。</p>\n<p>愿我们都能够，<strong>面对现实，勇敢追求</strong>。</p>',
          toc: '[{"level":"2","id":"一、关于工作","text":"一、关于工作"},{"level":"3","id":"1-工作是什么","text":"1. 工作是什么"},{"level":"3","id":"2-作为工程师","text":"2. 作为工程师"},{"level":"3","id":"3-作为团队成员","text":"3. 作为团队成员"},{"level":"2","id":"二、关于成长","text":"二、关于成长"},{"level":"3","id":"1-永存的困惑","text":"1. 永存的困惑"},{"level":"3","id":"2-历史与现实","text":"2. 历史与现实"},{"level":"3","id":"3-发展与未来","text":"3. 发展与未来"},{"level":"4","id":"31-硬技能","text":"3.1 硬技能"},{"level":"4","id":"32-软技能","text":"3.2 软技能"},{"level":"2","id":"三、关于价值观","text":"三、关于价值观"}]',
          status: 'publish',
          views: 3914,
          likes: 94,
          isRecommended: false,
          needPassword: false,
          isCommentable: true,
          publishAt: '2022-04-12T01:17:45.000Z',
          createAt: '2021-05-14T10:26:02.709Z',
          updateAt: '2022-05-07T02:57:46.000Z',
        },
        {
          id: '728d9688-b80f-481a-8e1f-5a61cee4fae2',
          title: '基于 sqlite3 实现全文搜索',
          cover:
            'https://wipi.oss-cn-shanghai.aliyuncs.com/2021-10-18/sqlite3-fts.webp',
          summary:
            '本文依赖 sqlite3 和 fts5，基于 better-sqlite3 实现全文搜索。',
          content:
            "本文依赖 `sqlite3` 和 `fts5`，基于 `better-sqlite3` 实现。\n\n## TL,DR\n\n使用 sqlite3 新建数据库，然后建表，然后插入数据，然后查询，即可。\n\n```js\nconst Database = require('better-sqlite3');\n\n// 1. 建库\nconst db = new Database('./wipi.db', { verbose: console.log });\n\n// 2. 建表\ndb.exec(`\nCREATE VIRTUAL TABLE article USING FTS5(id, title, summary, content);\n`);\n\n// 3. 插数\nconst insert = db.prepare('INSERT INTO article (id, title, summary, content) VALUES (@id, @title, @summary, @content)');\n\n// 4. 查询\nconst query = db.prepare(`\nSELECT *\nFROM article\nWHERE article MATCH '关键字'\nORDER BY rank;\n`);\nquery.all()\n```\n\n## 中文搜索\n\n如果需要实现中文的全文搜索，需要引入中文分词插件，涉及到的方法为：`db.loadExtension`。以 `https://github.com/wangfenjin/simple` 为例，下载各平台的 release 包，然后加载扩展，实现中文搜索。\n\n\n```js\n// 1. 加载扩展\ndb.loadExtension(''); // 注意为绝对路径\n\n// 2. 建表时指定分词器\ndb.exec(`CREATE VIRTUAL TABLE IF NOT EXISTS article USING fts5(id, title, summary, content, status, tokenize = 'simple'`);\n\n// 3. 查询时指定匹配方法\nconst query = db.prepare(`\n    SELECT *\n    FROM article\n    WHERE article match simple_query('关键词')\n    ORDER BY rank;\n`);\n\nquery.all();\n```\n",
          html: "<p>本文依赖 <code>sqlite3</code> 和 <code>fts5</code>，基于 <code>better-sqlite3</code> 实现。</p>\n<h2 id=\"tldr\">TL,DR</h2>\n<p>使用 sqlite3 新建数据库，然后建表，然后插入数据，然后查询，即可。</p>\n<pre><code class=\"js language-js\">const Database = require('better-sqlite3');\n\n// 1. 建库\nconst db = new Database('./wipi.db', { verbose: console.log });\n\n// 2. 建表\ndb.exec(`\nCREATE VIRTUAL TABLE article USING FTS5(id, title, summary, content);\n`);\n\n// 3. 插数\nconst insert = db.prepare('INSERT INTO article (id, title, summary, content) VALUES (@id, @title, @summary, @content)');\n\n// 4. 查询\nconst query = db.prepare(`\nSELECT *\nFROM article\nWHERE article MATCH '关键字'\nORDER BY rank;\n`);\nquery.all()\n</code></pre>\n<h2 id=\"中文搜索\">中文搜索</h2>\n<p>如果需要实现中文的全文搜索，需要引入中文分词插件，涉及到的方法为：<code>db.loadExtension</code>。以 <code>https://github.com/wangfenjin/simple</code> 为例，下载各平台的 release 包，然后加载扩展，实现中文搜索。</p>\n<pre><code class=\"js language-js\">// 1. 加载扩展\ndb.loadExtension(''); // 注意为绝对路径\n\n// 2. 建表时指定分词器\ndb.exec(`CREATE VIRTUAL TABLE IF NOT EXISTS article USING fts5(id, title, summary, content, status, tokenize = 'simple'`);\n\n// 3. 查询时指定匹配方法\nconst query = db.prepare(`\n    SELECT *\n    FROM article\n    WHERE article match simple_query('关键词')\n    ORDER BY rank;\n`);\n\nquery.all();\n</code></pre>",
          toc: '[{"level":"2","id":"tldr","text":"TL,DR"},{"level":"2","id":"中文搜索","text":"中文搜索"}]',
          status: 'publish',
          views: 1074,
          likes: 19,
          isRecommended: false,
          needPassword: false,
          isCommentable: true,
          publishAt: '2022-04-12T01:17:45.000Z',
          createAt: '2021-10-17T19:01:27.092Z',
          updateAt: '2022-05-08T04:02:14.000Z',
        },
        {
          id: '8901e0c2-fc67-4f88-98c8-3d6bdcca6f17',
          title: '深刻缅怀袁隆平',
          cover:
            'https://wipi.oss-cn-shanghai.aliyuncs.com/2021-05-24/WechatIMG1.jpeg',
          summary: '国家有希望，人民有信仰，送别真正的国士。',
          content:
            '<h2 align="center" style="border: 0">国家有希望，人民有信仰，送别真正的国士。</h2>',
          html: '<h2 align="center" style="border: 0">国家有希望，人民有信仰，送别真正的国士。</h2>',
          toc: '[]',
          status: 'publish',
          views: 5111,
          likes: 106,
          isRecommended: false,
          needPassword: false,
          isCommentable: true,
          publishAt: '2022-04-12T01:17:45.000Z',
          createAt: '2021-05-24T05:42:00.102Z',
          updateAt: '2022-05-08T03:46:19.000Z',
        },
        {
          id: 'a03634b2-69ef-4d6e-8674-753c64c2456f',
          title: '关于个人发展',
          cover:
            'https://wipi.oss-cn-shanghai.aliyuncs.com/2021-04-28/ec4cb91c5e48f021f70b2d6359107355(1).jpg',
          summary: '关于时间管理和知识管理，不要停止思考。',
          content:
            '## 此生理想、近期规划、今日功课\n\n> 此生理想、近期规划、今日功课。 --马鹤凌（马英九父亲）\n\n1. 理想要远，不怕够不着，就怕已经快够着了\n\n大多数人在当下并不能真正地想出自己的理想是什么。**不刻意去追寻理想，活在当下**也许是一个好的实践。专注于解决问题，积累经验。也不要给自己设限，用于尝试多种可能，逐步排除掉自己不想要的。\n\n2. 规划要近，太远会觉得还有很多时间\n\n不做远期规划，不然容易变成一直拖着。做短期内的计划，保持节奏让工作和学习有序前行。\n\n3. 行动要在现在\n\n一个人很有可能要工作 20 年以上，这是一场长跑。在这场长跑中，很多当下的问题只是浪花一朵，比如晋升、绩效、涨薪等，很多看似不可能的行动变为可能，比如掌握 n 种编程语言、研究内核等。为了跑好这场长跑，还是要做好每日功课。\n\n- 给自己一个安静的环境，省出学习时间\n- 持续学习\n- 健康的体魄\n\n## 学习和成长\n\n一个人很有可能要工作 20 年以上，现在才工作了多久？作为技术同学，所掌握的某个技术很有可能一夜之间就过时了，要居安思危，逃离舒服区。\n\n关于学习，基础知识很重要，要关注现实和实用。可以大量购买和阅读书籍，同时做好知识管理。\n\n关于成长，抛出一个问题：3年开发经验，是学习了1年，重复工作了2年，还是有一定的进步？\n\n## 执行\n\n### 要事优先\n\n讲事情按照**重要**和**紧急**分为4个象限。\n\n```bash\n                  紧急\n                   |\n                   |\n                   |\n                   |\n不重要 <--------------------------> 重要\n                   |\n                   |\n                   |\n                   |\n                 不紧急\n```\n\n用自己价值观来判断，不要在不重要的事情上浪费时间。\n\n### 无视不重要的事情\n\n```bash\n                  紧急\n                   |\n                   |\n                   |\n                   |\n                   --------------> 重要\n                   |\n                   |\n                   |\n                   |\n                 不紧急\n```\n\n**重要但不紧急**的事情迟早会变成**重要且紧急**的事情，所以大部分时间应该花在**重要不紧急**的事情上，不要等到紧急的时候去**救急**。\n\n### 目标分解\n\n在执行时，目标往往很大，需要进行适当的分解，以便执行。没有分解的目标，很难有阶段性成果，会发现一直在做一件事，然后还做不好。任务一定要具体、可量化、可执行。\n\n\n## 参考\n\n1. [⾼⼯的个人发展规划](https://speakerdeck.com/baidufe/gong-cheng-shi-de-ge-ren-fa-zhan-gui-hua)\n2. [About Time and Knowledge Management](https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md)\n\n\n',
          html: '<h2 id="此生理想、近期规划、今日功课">此生理想、近期规划、今日功课</h2>\n<blockquote>\n  <p>此生理想、近期规划、今日功课。 --马鹤凌（马英九父亲）</p>\n</blockquote>\n<ol>\n<li>理想要远，不怕够不着，就怕已经快够着了</li>\n</ol>\n<p>大多数人在当下并不能真正地想出自己的理想是什么。<strong>不刻意去追寻理想，活在当下</strong>也许是一个好的实践。专注于解决问题，积累经验。也不要给自己设限，用于尝试多种可能，逐步排除掉自己不想要的。</p>\n<ol start="2">\n<li>规划要近，太远会觉得还有很多时间</li>\n</ol>\n<p>不做远期规划，不然容易变成一直拖着。做短期内的计划，保持节奏让工作和学习有序前行。</p>\n<ol start="3">\n<li>行动要在现在</li>\n</ol>\n<p>一个人很有可能要工作 20 年以上，这是一场长跑。在这场长跑中，很多当下的问题只是浪花一朵，比如晋升、绩效、涨薪等，很多看似不可能的行动变为可能，比如掌握 n 种编程语言、研究内核等。为了跑好这场长跑，还是要做好每日功课。</p>\n<ul>\n<li>给自己一个安静的环境，省出学习时间</li>\n<li>持续学习</li>\n<li>健康的体魄</li>\n</ul>\n<h2 id="学习和成长">学习和成长</h2>\n<p>一个人很有可能要工作 20 年以上，现在才工作了多久？作为技术同学，所掌握的某个技术很有可能一夜之间就过时了，要居安思危，逃离舒服区。</p>\n<p>关于学习，基础知识很重要，要关注现实和实用。可以大量购买和阅读书籍，同时做好知识管理。</p>\n<p>关于成长，抛出一个问题：3年开发经验，是学习了1年，重复工作了2年，还是有一定的进步？</p>\n<h2 id="执行">执行</h2>\n<h3 id="要事优先">要事优先</h3>\n<p>讲事情按照<strong>重要</strong>和<strong>紧急</strong>分为4个象限。</p>\n<pre><code class="bash language-bash">                  紧急\n                   |\n                   |\n                   |\n                   |\n不重要 &lt;--------------------------&gt; 重要\n                   |\n                   |\n                   |\n                   |\n                 不紧急\n</code></pre>\n<p>用自己价值观来判断，不要在不重要的事情上浪费时间。</p>\n<h3 id="无视不重要的事情">无视不重要的事情</h3>\n<pre><code class="bash language-bash">                  紧急\n                   |\n                   |\n                   |\n                   |\n                   --------------&gt; 重要\n                   |\n                   |\n                   |\n                   |\n                 不紧急\n</code></pre>\n<p><strong>重要但不紧急</strong>的事情迟早会变成<strong>重要且紧急</strong>的事情，所以大部分时间应该花在<strong>重要不紧急</strong>的事情上，不要等到紧急的时候去<strong>救急</strong>。</p>\n<h3 id="目标分解">目标分解</h3>\n<p>在执行时，目标往往很大，需要进行适当的分解，以便执行。没有分解的目标，很难有阶段性成果，会发现一直在做一件事，然后还做不好。任务一定要具体、可量化、可执行。</p>\n<h2 id="参考">参考</h2>\n<ol>\n<li><a href="https://speakerdeck.com/baidufe/gong-cheng-shi-de-ge-ren-fa-zhan-gui-hua">⾼⼯的个人发展规划</a></li>\n<li><a href="https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md">About Time and Knowledge Management</a></li>\n</ol>',
          toc: '[{"level":"2","id":"此生理想、近期规划、今日功课","text":"此生理想、近期规划、今日功课"},{"level":"2","id":"学习和成长","text":"学习和成长"},{"level":"2","id":"执行","text":"执行"},{"level":"3","id":"要事优先","text":"要事优先"},{"level":"3","id":"无视不重要的事情","text":"无视不重要的事情"},{"level":"3","id":"目标分解","text":"目标分解"},{"level":"2","id":"参考","text":"参考"}]',
          status: 'publish',
          views: 4010,
          likes: 43,
          isRecommended: false,
          needPassword: false,
          isCommentable: true,
          publishAt: '2022-04-12T01:17:45.000Z',
          createAt: '2021-05-19T06:14:31.013Z',
          updateAt: '2022-05-08T15:36:02.000Z',
        },
        {
          id: 'aa5104bd-f6dd-4e85-a1a0-de60de24b0ad',
          title: 'Unix 中可以立即使用的程序（一）',
          cover: null,
          summary: null,
          content:
            '## 此生理想、近期规划、今日功课\n\n> 此生理想、近期规划、今日功课。 --马鹤凌（马英九父亲）\n\n1. 理想要远，不怕够不着，就怕已经快够着了\n\n大多数人在当下并不能真正地想出自己的理想是什么。**不刻意去追寻理想，活在当下**也许是一个好的实践。专注于解决问题，积累经验。也不要给自己设限，用于尝试多种可能，逐步排除掉自己不想要的。\n\n2. 规划要近，太远会觉得还有很多时间\n\n不做远期规划，不然容易变成一直拖着。做短期内的计划，保持节奏让工作和学习有序前行。\n\n3. 行动要在现在\n\n一个人很有可能要工作 20 年以上，这是一场长跑。在这场长跑中，很多当下的问题只是浪花一朵，比如晋升、绩效、涨薪等，很多看似不可能的行动变为可能，比如掌握 n 种编程语言、研究内核等。为了跑好这场长跑，还是要做好每日功课。\n\n- 给自己一个安静的环境，省出学习时间\n- 持续学习\n- 健康的体魄\n\n## 学习和成长\n\n一个人很有可能要工作 20 年以上，现在才工作了多久？作为技术同学，所掌握的某个技术很有可能一夜之间就过时了，要居安思危，逃离舒服区。\n\n关于学习，基础知识很重要，要关注现实和实用。可以大量购买和阅读书籍，同时做好知识管理。\n\n关于成长，抛出一个问题：3年开发经验，是学习了1年，重复工作了2年，还是有一定的进步？\n\n## 执行\n\n### 要事优先\n\n讲事情按照**重要**和**紧急**分为4个象限。\n\n```bash\n                  紧急\n                   |\n                   |\n                   |\n                   |\n不重要 <--------------------------> 重要\n                   |\n                   |\n                   |\n                   |\n                 不紧急\n```\n\n用自己价值观来判断，不要在不重要的事情上浪费时间。\n\n### 无视不重要的事情\n\n```bash\n                  紧急\n                   |\n                   |\n                   |\n                   |\n                   --------------> 重要\n                   |\n                   |\n                   |\n                   |\n                 不紧急\n```\n\n**重要但不紧急**的事情迟早会变成**重要且紧急**的事情，所以大部分时间应该花在**重要不紧急**的事情上，不要等到紧急的时候去**救急**。\n\n### 目标分解\n\n在执行时，目标往往很大，需要进行适当的分解，以便执行。没有分解的目标，很难有阶段性成果，会发现一直在做一件事，然后还做不好。任务一定要具体、可量化、可执行。\n\n\n## 参考\n\n1. [⾼⼯的个人发展规划](https://speakerdeck.com/baidufe/gong-cheng-shi-de-ge-ren-fa-zhan-gui-hua)\n2. [About Time and Knowledge Management](https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md)\n\n\n',
          html: '<h2 id="此生理想、近期规划、今日功课">此生理想、近期规划、今日功课</h2>\n<blockquote>\n  <p>此生理想、近期规划、今日功课。 --马鹤凌（马英九父亲）</p>\n</blockquote>\n<ol>\n<li>理想要远，不怕够不着，就怕已经快够着了</li>\n</ol>\n<p>大多数人在当下并不能真正地想出自己的理想是什么。<strong>不刻意去追寻理想，活在当下</strong>也许是一个好的实践。专注于解决问题，积累经验。也不要给自己设限，用于尝试多种可能，逐步排除掉自己不想要的。</p>\n<ol start="2">\n<li>规划要近，太远会觉得还有很多时间</li>\n</ol>\n<p>不做远期规划，不然容易变成一直拖着。做短期内的计划，保持节奏让工作和学习有序前行。</p>\n<ol start="3">\n<li>行动要在现在</li>\n</ol>\n<p>一个人很有可能要工作 20 年以上，这是一场长跑。在这场长跑中，很多当下的问题只是浪花一朵，比如晋升、绩效、涨薪等，很多看似不可能的行动变为可能，比如掌握 n 种编程语言、研究内核等。为了跑好这场长跑，还是要做好每日功课。</p>\n<ul>\n<li>给自己一个安静的环境，省出学习时间</li>\n<li>持续学习</li>\n<li>健康的体魄</li>\n</ul>\n<h2 id="学习和成长">学习和成长</h2>\n<p>一个人很有可能要工作 20 年以上，现在才工作了多久？作为技术同学，所掌握的某个技术很有可能一夜之间就过时了，要居安思危，逃离舒服区。</p>\n<p>关于学习，基础知识很重要，要关注现实和实用。可以大量购买和阅读书籍，同时做好知识管理。</p>\n<p>关于成长，抛出一个问题：3年开发经验，是学习了1年，重复工作了2年，还是有一定的进步？</p>\n<h2 id="执行">执行</h2>\n<h3 id="要事优先">要事优先</h3>\n<p>讲事情按照<strong>重要</strong>和<strong>紧急</strong>分为4个象限。</p>\n<pre><code class="bash language-bash">                  紧急\n                   |\n                   |\n                   |\n                   |\n不重要 &lt;--------------------------&gt; 重要\n                   |\n                   |\n                   |\n                   |\n                 不紧急\n</code></pre>\n<p>用自己价值观来判断，不要在不重要的事情上浪费时间。</p>\n<h3 id="无视不重要的事情">无视不重要的事情</h3>\n<pre><code class="bash language-bash">                  紧急\n                   |\n                   |\n                   |\n                   |\n                   --------------&gt; 重要\n                   |\n                   |\n                   |\n                   |\n                 不紧急\n</code></pre>\n<p><strong>重要但不紧急</strong>的事情迟早会变成<strong>重要且紧急</strong>的事情，所以大部分时间应该花在<strong>重要不紧急</strong>的事情上，不要等到紧急的时候去<strong>救急</strong>。</p>\n<h3 id="目标分解">目标分解</h3>\n<p>在执行时，目标往往很大，需要进行适当的分解，以便执行。没有分解的目标，很难有阶段性成果，会发现一直在做一件事，然后还做不好。任务一定要具体、可量化、可执行。</p>\n<h2 id="参考">参考</h2>\n<ol>\n<li><a href="https://speakerdeck.com/baidufe/gong-cheng-shi-de-ge-ren-fa-zhan-gui-hua">⾼⼯的个人发展规划</a></li>\n<li><a href="https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md">About Time and Knowledge Management</a></li>\n</ol>',
          toc: '[{"level":"2","id":"在系统中查找程序","text":"在系统中查找程序"},{"level":"2","id":"停止程序","text":"停止程序"},{"level":"2","id":"显示时间和日期","text":"显示时间和日期"},{"level":"2","id":"显示日历","text":"显示日历"},{"level":"3","id":"显示当前月份日历","text":"显示当前月份日历"},{"level":"3","id":"显示某一年的日历","text":"显示某一年的日历"},{"level":"3","id":"显示某年某月日历","text":"显示某年某月日历"},{"level":"3","id":"查看某一日是一年中的第几天","text":"查看某一日是一年中的第几天"},{"level":"3","id":"判断某一年是否为闰年","text":"判断某一年是否为闰年"},{"level":"2","id":"unix-提醒服务","text":"Unix 提醒服务"},{"level":"2","id":"查看系统信息","text":"查看系统信息"},{"level":"3","id":"uptime","text":"uptime"},{"level":"3","id":"hostname","text":"hostname"},{"level":"3","id":"uname","text":"uname"},{"level":"2","id":"查看用户信息","text":"查看用户信息"},{"level":"2","id":"提醒何时离开：leave","text":"提醒何时离开：leave"}]',
          status: 'publish',
          views: 11682,
          likes: 25,
          isRecommended: false,
          needPassword: false,
          isCommentable: true,
          publishAt: '2022-04-12T01:17:45.000Z',
          createAt: '2021-07-04T01:38:17.816Z',
          updateAt: '2022-04-26T06:01:10.000Z',
        },
        {
          id: 'db67efc4-3020-4ba9-95bb-8bb96a198b4a',
          title: '计算机工作原理',
          cover:
            'https://wipi.oss-cn-shanghai.aliyuncs.com/2021-05-13/telework-5059653_1280.webp',
          summary:
            '无论你用计算机做什么，计算机所做的都是：从物理世界输入信息，存储和处理信息，输出到物理世界。\n',
          content:
            '## 计算机的组成部分\n\n- 输入（信息）\n- 存储（信息）\n- 处理（信息）\n- 输出（信息）\n\n这就是计算机的组成部分。\n\n\n## 电路和逻辑\n\n每个计算机的输入输出实际上都是信息，都能通过电子信号的开/关来表示（也就是 1 和 0）。计算机需要改变输入的信息，为了这个，使用上百万个很小的电子元件来组成电路。电路之间组合形成逻辑运算。\n\n## 数据和二进制\n\n### 二进制\n\n二进制只有两个数字：0、1。相对于十进制，每进一位乘 2 即可。\n\n### 数据\n\n所有的数据都可以转换成二进制数字来表示，也就是 1 和 0，然后在计算机内部转换成电信号。\n\n## 硬件和软件\n\n计算机设备里面的一大堆电路、芯片、电线、扬声器等就是硬件。其他你在计算机设备里看不到的就是软件，也就是计算机上的所有程序、运行的代码等。\n计算机通过**操作系统**的特殊程序来管理软件如何使用硬件。\n\n## 存储、CPU、输入和输出\n\n所有的计算机都在做同样的 4 件事：输入信息、存储信息、处理信息、输出信息。每一件事通过不同的部分来完成。\n\n1. 输入设备从外部世界获取输入，并转换为二进制信息\n2. 存储来保存这些信息\n3. CPU 来处理信息\n4. 输出设备获取信息，转换为物理输出\n\n## 总结\n\n无论你用计算机做什么，计算机所做的都是：从物理世界输入信息，存储和处理信息，输出到物理世界。\n\n',
          html: '<h2 id="计算机的组成部分">计算机的组成部分</h2>\n<ul>\n<li>输入（信息）</li>\n<li>存储（信息）</li>\n<li>处理（信息）</li>\n<li>输出（信息）</li>\n</ul>\n<p>这就是计算机的组成部分。</p>\n<h2 id="电路和逻辑">电路和逻辑</h2>\n<p>每个计算机的输入输出实际上都是信息，都能通过电子信号的开/关来表示（也就是 1 和 0）。计算机需要改变输入的信息，为了这个，使用上百万个很小的电子元件来组成电路。电路之间组合形成逻辑运算。</p>\n<h2 id="数据和二进制">数据和二进制</h2>\n<h3 id="二进制">二进制</h3>\n<p>二进制只有两个数字：0、1。相对于十进制，每进一位乘 2 即可。</p>\n<h3 id="数据">数据</h3>\n<p>所有的数据都可以转换成二进制数字来表示，也就是 1 和 0，然后在计算机内部转换成电信号。</p>\n<h2 id="硬件和软件">硬件和软件</h2>\n<p>计算机设备里面的一大堆电路、芯片、电线、扬声器等就是硬件。其他你在计算机设备里看不到的就是软件，也就是计算机上的所有程序、运行的代码等。<br />\n计算机通过<strong>操作系统</strong>的特殊程序来管理软件如何使用硬件。</p>\n<h2 id="存储、cpu、输入和输出">存储、CPU、输入和输出</h2>\n<p>所有的计算机都在做同样的 4 件事：输入信息、存储信息、处理信息、输出信息。每一件事通过不同的部分来完成。</p>\n<ol>\n<li>输入设备从外部世界获取输入，并转换为二进制信息</li>\n<li>存储来保存这些信息</li>\n<li>CPU 来处理信息</li>\n<li>输出设备获取信息，转换为物理输出</li>\n</ol>\n<h2 id="总结">总结</h2>\n<p>无论你用计算机做什么，计算机所做的都是：从物理世界输入信息，存储和处理信息，输出到物理世界。</p>',
          toc: '[{"level":"2","id":"计算机的组成部分","text":"计算机的组成部分"},{"level":"2","id":"电路和逻辑","text":"电路和逻辑"},{"level":"2","id":"数据和二进制","text":"数据和二进制"},{"level":"3","id":"二进制","text":"二进制"},{"level":"3","id":"数据","text":"数据"},{"level":"2","id":"硬件和软件","text":"硬件和软件"},{"level":"2","id":"存储、cpu、输入和输出","text":"存储、CPU、输入和输出"},{"level":"2","id":"总结","text":"总结"}]',
          status: 'publish',
          views: 3641,
          likes: 96,
          isRecommended: false,
          needPassword: false,
          isCommentable: true,
          publishAt: '2022-04-12T01:17:45.000Z',
          createAt: '2021-05-13T08:28:18.735Z',
          updateAt: '2022-05-05T10:20:18.000Z',
        },
        {
          id: 'b83d1a2d-fbe6-44af-bc44-1d1442087930',
          title: '微信小程序首屏性能优化',
          cover:
            'https://wipi.oss-cn-shanghai.aliyuncs.com/2021-12-11/IMG_031434567.jpeg',
          summary: '老生常谈的性能优化，在微信小程序中又应该如何去实践？',
          content:
            "## 首屏时间定义\n\n小程序启动流程：\n\n点击小程序图标 → 小程序启动 → 页面开始加载 → 页面主要框架加载完成 → 图片及资源下载 → 页面完全加载\n\n其中，从点击小程序图标开始到页面主要框架加载完成是首屏启动时间。\n\n## 优化治理\n\n首屏启动时间分为小程序启动和页面加载完成两阶段，需要分开治理优化。\n\n![首屏加载时机](https://wipi.oss-cn-shanghai.aliyuncs.com/2021-12-08/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD.png)\n\n### 小程序启动阶段\n\n小程序框架启动主要包括小程序信息及环境准备、代码包下载和代码编译三个主要步骤。对开发者来说都是黑盒实现，只能根据官方文档和开发经验来总结实际的影响点。目前来看，从开发者角度来说，就是减少发版频次。因为发版会导致小程序启动时需要更新信息，并有阻塞逻辑。同时，代码包下载和编译受大小影响，需要控制代码体积。\n\n### 首屏渲染阶段\n\n#### 1. 初始执行优化\n\n根据启动阶段的必要性，建立优先级机制：\n\n- 阻塞首屏渲染的逻辑同步执行\n- 不影响首屏渲染的逻辑延迟执行\n\n比如，通过 wx:if 控制非首屏组件延迟加载（如各类弹窗、挂件），在首屏渲染完成后再加载渲染，不仅可以节省组件初始化耗时，还可以减少首屏期间网络请求和 setData。此外，上报接口、非首屏依赖 SDK 等非首屏依赖项延迟执行。\n\n#### 2. 数据加载优化\n\n##### 1. 缓存数据读取\n\n在组件 attached 阶段通过 wx.getStorageSync 读取并使用缓存进行渲染\n\n##### 2. 接口请求优化\n\n在 app 的 onLaunch 阶段对数据进行预加载，因为从 app onLaunch 到页面 onLoad 会需要几百毫秒耗时\n\n##### 3. 接口耗时优化\n\n主要通过接口合并、数据精简、域名合并等操作提升端到端耗时\n\n#### 3. 页面渲染优化\n\n小程序采用双线程渲染模型，逻辑层通过 setData 将数据发送到视图层，视图层对比前后差异，更新 DOM。setData 受次数和数据量影响，WXML 受 DOM 节点数量和层级影响。\n\n##### 1. setData\n\n控制数据量（非渲染数据不要放到 data 里），延迟执行非首屏的 setData，合并 setData 来优化次数等。\n\n##### 2. WXML\n\n删除冗余节点，优化节点层级。\n\n##### 3. 图片\n\nC 端业务往往会使用大量图片。图片本身所要占据的内存也比较大，可以对图片进行压缩裁剪，缓存（减少网络请求及带宽消耗）以及图片 lazyload，同时可以结合存储服务（如 s3）对图片进行压缩、裁剪，以及使用 webp 格式。\n\n## 技术手段\n\n### setData 的优化\n\nsetData 方面的优化只能从次数和数据量来入手。次数优化的手段：收集一段时间内的 setData 合并成一次 setData；数据大小的优化：对 setData 提交的数据和之前的数据进行 diff，diff 成形如：`this.setData({ 'a.b.c': 'newVal' })` 进行精准更新。为此，可以劫持微信的 `setData`，为其加上 `diff` 和调度更新的能力。\n\n#### 调度手段\n\n横向调研了几个开源框架的调度方案：\n\n- Taro3：setTimeout 0 进行合并 setData\n- Wepy2 和 Mpvue：使用 throttle 50 进行合并 setData\n- MPX：使用 Promise.then 进行合并 setData\n\n结合真机测试数据，最终选择了 setTimeout 的合并调度 setData 策略。\n\n#### 编码实现\n\n1. 对 data 进行 diff，控制数据量\n2. 减少 setData 次数，作合并\n3. onReady 之前的 setData 统一合并\n\n\n##### diff\n\n```js\nconst OBJECT_TYPE = '[object Object]';\nconst ARRAY_TYPE = '[object Array]';\n\nconst getType = obj => Object.prototype.toString.call(obj);\n\nconst initPath = data => {\n    if (getType(data) !== OBJECT_TYPE) return;\n    for (const item in data) {\n        if (/\\w+\\.\\w+/g.test(item) && item.indexOf('[') === -1) {\n            const arr = item.split('.');\n            let result = data;\n            const len = arr.length;\n            for (let i = 0; i < len - 1; i++) {\n                const arrItem = arr[i];\n                if (getType(result[arrItem]) !== OBJECT_TYPE) {\n                    result[arrItem] = {};\n                }\n                result = result[arrItem];\n            }\n            result[arr[len - 1]] = data[item];\n            delete data[item];\n        }\n    }\n};\n\nconst initData = (cur, pre, root = false) => {\n    if (cur === pre) return;\n    const curType = getType(cur);\n    const preType = getType(pre);\n    if (curType !== preType) return;\n    if (curType === ARRAY_TYPE && cur.length >= pre.length) {\n        for (let i = 0; i < pre.length; i++) {\n            initData(cur[i], pre[i]);\n        }\n    } else if (curType === OBJECT_TYPE && Object.keys(cur).length >= Object.keys(pre).length) {\n        for (const key in pre) {\n            if (!root && cur[key] === undefined) {\n                cur[key] = null;\n            } else {\n                initData(cur[key], pre[key]);\n            }\n        }\n    }\n};\n\nconst doDiff = (cur, pre, target, path = '', root = false) => {\n    if (cur === pre) return;\n    const curRootType = getType(cur);\n    const preRootType = getType(pre);\n    if (curRootType === ARRAY_TYPE && preRootType === curRootType && cur.length >= pre.length) {\n        for (let i = 0; i < cur.length; i++) {\n            doDiff(cur[i], pre[i], target, `${path}[${i}]`);\n        }\n        return;\n    }\n    if (\n        curRootType === OBJECT_TYPE &&\n        preRootType === curRootType &&\n        (root || Object.keys(cur).length >= Object.keys(pre).length)\n    ) {\n        const keys = Object.keys(cur);\n        for (const key of keys) {\n            const curVal = cur[key];\n            const preVal = pre[key];\n            const curType = getType(curVal);\n            const preType = getType(preVal);\n            if (curVal === preVal) continue;\n            if (curType === ARRAY_TYPE && preType === curType && curVal.length >= preVal.length) {\n                for (let i = 0; i < curVal.length; i++) {\n                    doDiff(curVal[i], preVal[i], target, `${path ? `${path}.` : ''}${key}[${i}]`);\n                }\n                continue;\n            }\n            if (\n                curType === OBJECT_TYPE &&\n                preType === curType &&\n                Object.keys(curVal).length >= Object.keys(preVal).length\n            ) {\n                for (const sKey in curVal) {\n                    doDiff(curVal[sKey], preVal[sKey], target, `${path ? `${path}.` : ''}${key}.${sKey}`);\n                }\n                continue;\n            }\n            target[`${path ? `${path}.` : ''}${key}`] = curVal;\n        }\n        return;\n    }\n    target[path] = cur;\n};\n\nexport function diffData(data, prevData) {\n    const target = {};\n    initPath(data);\n    initData(data, prevData, true);\n    doDiff(data, prevData, target, '', true);\n    return target;\n}\n```\n\n##### reconcile\n\n```js\nexport function noop() {}\n\n\nexport function shape(source, target) {\n    const accumulator = {};\n    const keys = Object.keys(target);\n\n    for (const key of keys) {\n        accumulator[key] = source[key];\n    }\n\n    return accumulator;\n}\n\nfunction _basePath(path) {\n    if (Array.isArray(path)) return path;\n    return path.replace(/\\[/g, '.').replace(/\\]/g, '').split('.')\n}\n\nfunction set(object, path, value) {\n    if (typeof object !== 'object') return object;\n\n    _basePath(path).reduce((o, k, i, _) => {\n        if (i === _.length - 1) {\n            o[k] = value\n            return null\n        } else if (k in o) {\n            return o[k]\n        } else {\n            o[k] = /^[0-9]{1,}$/.test(_[i + 1]) ? [] : {}\n            return o[k]\n        }\n    }, object)\n\n    return object;\n}\n\nexport function syncData(ctx, data) {\n    Object.keys(data).forEach(key => {\n        set(ctx.data, key, data[key])\n    })\n}\n\nfunction getTick() {\n    return fn => setTimeout(fn, 0);\n}\n\nexport const tick = getTick();\n\nexport class Stream {\n    data: Array<unknown> = [];\n    listeners = {};\n    hasEnd: boolean = false;\n\n    constructor () {\n        this.data = [];\n        this.listeners = {};\n        this.hasEnd = false;\n    }\n\n    on(key, callback) {\n        if (typeof callback !== 'function') return;\n\n        this.listeners[key] = this.listeners[key] || [];\n        this.listeners[key].push(callback);\n    }\n\n    emit(key, ...args) {\n        const callbacks = this.listeners[key] || [];\n\n        for (const cb of callbacks) {\n            cb(...args);\n        }\n    }\n\n    add(data) {\n        this.data.push(data);\n        this.emit('data', data)\n    }\n\n    end() {\n        if (this.hasEnd) return;\n        this.hasEnd = true;\n        this.emit('end', this.data);\n    }\n\n    getData() {\n        if (!this.data.length) return null;\n\n        const ret = Object.create(null);\n\n        while (this.data.length > 0) {\n            const unit = this.data.shift();\n            Object.assign(ret, unit);\n        }\n\n        return ret;\n    }\n\n    destroy() {\n        this.data = [];\n        this.listeners = {};\n        this.hasEnd = false;\n    }\n}\n\n\nexport function getReconciler() {\n    let onLoadTime = 0;\n    let mounted = null;\n    let perf = null;\n    let ctx = null;\n    let workingDiffs = [];\n    let workingCallbacks = [];\n    let pendingUpdate = false;\n    let pendingFlush = false;\n    let beforeMountedSetData = [];\n    let beforeMountedCallback = [];\n\n    let stream = null;\n\n    function enqueueUpdate(data) {\n        workingDiffs.push(data);\n\n        if (!pendingUpdate) {\n            performUpdate();\n        }\n    }\n\n    function enqueueUpdateCallback(callback) {\n        workingCallbacks.push(() => {\n            callback();\n        });\n    }\n\n    function performUpdate() {\n        pendingUpdate = true;\n\n        const render = () => {\n            perf && perf.start();\n            const data = Object.create(null);\n\n            while (workingDiffs.length > 0) {\n                const diff = workingDiffs.shift();\n                Object.assign(data, diff);\n            }\n\n            pendingUpdate = false;\n            perf && perf.record(data);\n\n            ctx && ctx.originalSetData(data, () => {\n                perf && perf.stop();\n                if (!pendingFlush) {\n                    flushUpdateCallback();\n                }\n            });\n        }\n\n        tick(render);\n    }\n\n    function flushUpdateCallback() {\n        pendingFlush = true;\n        const cbs = workingCallbacks.slice(0);\n        workingCallbacks.length = 0;\n        for (const cb of cbs) {\n            cb();\n        }\n        pendingFlush = false;\n    }\n\n    function update(this: any, data, callback = noop) {\n        if (!ctx) ctx = this;\n        if (!perf) perf = getPerf({ ctx: this, onLoadTime, name: this.tag || this.data.tag || 'unknown' });\n        if (mounted === null) {\n            syncData(ctx, data)\n            stream?.add(data);\n            beforeMountedCallback.push(callback);\n            return;\n        }\n        if (mounted === false) return; // 已卸载\n\n        stream?.end();\n        perf?.count();\n\n        const previous = shape(ctx.data, data);\n        const diff = diffData(data, previous);\n        // 微信行为：同步更新数据\n        syncData(ctx, data);\n\n        if (!Object.keys(diff).length) return;\n\n        enqueueUpdate(diff);\n        enqueueUpdateCallback(callback);\n    }\n\n    function flushBeforeMountedSetDataCallbacks() {\n        const cbs = beforeMountedCallback.slice(0);\n        beforeMountedCallback.length = 0;\n        for (const cb of cbs) {\n            cb();\n        }\n    }\n\n    function init(this: any) {\n        onLoadTime = Date.now();\n        this.originalSetData = this.setData.bind(this);\n        this.setData = update.bind(this);\n        stream = new Stream();\n        stream?.on('end', () => {\n            const data = stream.getData();\n            if (!data) return;\n            this.originalSetData(data, flushBeforeMountedSetDataCallbacks);\n        })\n    }\n\n    function mount(this: any) {\n        mounted = true;\n        stream?.end();\n    }\n\n    function unmount() {\n        stream = null;\n        mounted = false;\n        perf = null;\n        ctx = null;\n        workingDiffs = [];\n        workingCallbacks = [];\n        pendingUpdate = false;\n        pendingFlush = false;\n        beforeMountedSetData = [];\n        beforeMountedCallback= [];\n    }\n\n    return { init, mount, unmount };\n}\n```\n\n##### wrap\n\n```js\nexport function reconcileComponent(component) {\n    component.lifetimes = component.lifetimes || {};\n    const originalCreated = component.created || component.lifetimes.created || noop;\n    const originalDetached = component.detached || component.lifetimes.detached || noop;\n\n    let reconciler = null;\n\n    function created(this: any, ...args) {\n        reconciler = getReconciler();\n        reconciler.init.apply(this, args);\n        reconciler.mount.apply(this, args);\n        originalCreated.apply(this, args);\n    }\n\n    function detached(this: any, ...args) {\n        reconciler.unmount.apply(this, args);\n        originalDetached.apply(this, args);\n    }\n\n    component.created = created;\n    component.lifetimes.created = created;\n    component.detached = detached;\n    component.lifetimes.detached = detached;\n\n    return component;\n}\n\nexport function reconcilePage(page) {\n    const originalOnLoad = page.onLoad || noop;\n    const originalOnReady = page.onReady || noop;\n    const originalOnUnload = page.onUnload || noop;\n\n    let reconciler = null;\n\n    page.onLoad = function (...args) {\n        reconciler = getReconciler();\n        reconciler.init.apply(this, args);\n        originalOnLoad.apply(this, args);\n    };\n\n    page.onReady = function (...args) {\n        originalOnReady.apply(this, args);\n        reconciler.mount.apply(this, args);\n    };\n\n    page.onUnload = function (...args) {\n        reconciler.unmount.apply(this, args);\n        originalOnUnload.apply(this, args);\n    };\n\n    return page;\n}\n```\n\n\n## 总结\n\n小程序的首屏性能治理涉及到各阶段各个方面，需要各个监控埋点，分析优化。\n\n### 1. 启动优化\n\n   - 减少发版频次、控制代码包体积\n\n### 2. 渲染优化\n\n  - 延迟执行非首屏逻辑、延迟加载非首屏组件\n  - 接口请求：接口合并、数据精简、域名收敛、预加载\n  - 数据缓存\n  - setData：合并 setData 减少次数、控制数据量大小、数据 diff 精准更新\n  - WXML：控制节点数、层级\n  - 图片：压缩裁剪、懒加载、选择合适的格式（webp）、图片缓存\n\n",
          html: '<h2 id="首屏时间定义">首屏时间定义</h2>\n<p>小程序启动流程：</p>\n<p>点击小程序图标 → 小程序启动 → 页面开始加载 → 页面主要框架加载完成 → 图片及资源下载 → 页面完全加载</p>\n<p>其中，从点击小程序图标开始到页面主要框架加载完成是首屏启动时间。</p>\n<h2 id="优化治理">优化治理</h2>\n<p>首屏启动时间分为小程序启动和页面加载完成两阶段，需要分开治理优化。</p>\n<p><img src="https://wipi.oss-cn-shanghai.aliyuncs.com/2021-12-08/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD.png" alt="首屏加载时机" /></p>\n<h3 id="小程序启动阶段">小程序启动阶段</h3>\n<p>小程序框架启动主要包括小程序信息及环境准备、代码包下载和代码编译三个主要步骤。对开发者来说都是黑盒实现，只能根据官方文档和开发经验来总结实际的影响点。目前来看，从开发者角度来说，就是减少发版频次。因为发版会导致小程序启动时需要更新信息，并有阻塞逻辑。同时，代码包下载和编译受大小影响，需要控制代码体积。</p>\n<h3 id="首屏渲染阶段">首屏渲染阶段</h3>\n<h4 id="1-初始执行优化">1. 初始执行优化</h4>\n<p>根据启动阶段的必要性，建立优先级机制：</p>\n<ul>\n<li>阻塞首屏渲染的逻辑同步执行</li>\n<li>不影响首屏渲染的逻辑延迟执行</li>\n</ul>\n<p>比如，通过 wx:if 控制非首屏组件延迟加载（如各类弹窗、挂件），在首屏渲染完成后再加载渲染，不仅可以节省组件初始化耗时，还可以减少首屏期间网络请求和 setData。此外，上报接口、非首屏依赖 SDK 等非首屏依赖项延迟执行。</p>\n<h4 id="2-数据加载优化">2. 数据加载优化</h4>\n<h5 id="1-缓存数据读取">1. 缓存数据读取</h5>\n<p>在组件 attached 阶段通过 wx.getStorageSync 读取并使用缓存进行渲染</p>\n<h5 id="2-接口请求优化">2. 接口请求优化</h5>\n<p>在 app 的 onLaunch 阶段对数据进行预加载，因为从 app onLaunch 到页面 onLoad 会需要几百毫秒耗时</p>\n<h5 id="3-接口耗时优化">3. 接口耗时优化</h5>\n<p>主要通过接口合并、数据精简、域名合并等操作提升端到端耗时</p>\n<h4 id="3-页面渲染优化">3. 页面渲染优化</h4>\n<p>小程序采用双线程渲染模型，逻辑层通过 setData 将数据发送到视图层，视图层对比前后差异，更新 DOM。setData 受次数和数据量影响，WXML 受 DOM 节点数量和层级影响。</p>\n<h5 id="1-setdata">1. setData</h5>\n<p>控制数据量（非渲染数据不要放到 data 里），延迟执行非首屏的 setData，合并 setData 来优化次数等。</p>\n<h5 id="2-wxml">2. WXML</h5>\n<p>删除冗余节点，优化节点层级。</p>\n<h5 id="3-图片">3. 图片</h5>\n<p>C 端业务往往会使用大量图片。图片本身所要占据的内存也比较大，可以对图片进行压缩裁剪，缓存（减少网络请求及带宽消耗）以及图片 lazyload，同时可以结合存储服务（如 s3）对图片进行压缩、裁剪，以及使用 webp 格式。</p>\n<h2 id="技术手段">技术手段</h2>\n<h3 id="setdata-的优化">setData 的优化</h3>\n<p>setData 方面的优化只能从次数和数据量来入手。次数优化的手段：收集一段时间内的 setData 合并成一次 setData；数据大小的优化：对 setData 提交的数据和之前的数据进行 diff，diff 成形如：<code>this.setData({ \'a.b.c\': \'newVal\' })</code> 进行精准更新。为此，可以劫持微信的 <code>setData</code>，为其加上 <code>diff</code> 和调度更新的能力。</p>\n<h4 id="调度手段">调度手段</h4>\n<p>横向调研了几个开源框架的调度方案：</p>\n<ul>\n<li>Taro3：setTimeout 0 进行合并 setData</li>\n<li>Wepy2 和 Mpvue：使用 throttle 50 进行合并 setData</li>\n<li>MPX：使用 Promise.then 进行合并 setData</li>\n</ul>\n<p>结合真机测试数据，最终选择了 setTimeout 的合并调度 setData 策略。</p>\n<h4 id="编码实现">编码实现</h4>\n<ol>\n<li>对 data 进行 diff，控制数据量</li>\n<li>减少 setData 次数，作合并</li>\n<li>onReady 之前的 setData 统一合并</li>\n</ol>\n<h5 id="diff">diff</h5>\n<pre><code class="js language-js">const OBJECT_TYPE = \'[object Object]\';\nconst ARRAY_TYPE = \'[object Array]\';\n\nconst getType = obj =&gt; Object.prototype.toString.call(obj);\n\nconst initPath = data =&gt; {\n    if (getType(data) !== OBJECT_TYPE) return;\n    for (const item in data) {\n        if (/\\w+\\.\\w+/g.test(item) &amp;&amp; item.indexOf(\'[\') === -1) {\n            const arr = item.split(\'.\');\n            let result = data;\n            const len = arr.length;\n            for (let i = 0; i &lt; len - 1; i++) {\n                const arrItem = arr[i];\n                if (getType(result[arrItem]) !== OBJECT_TYPE) {\n                    result[arrItem] = {};\n                }\n                result = result[arrItem];\n            }\n            result[arr[len - 1]] = data[item];\n            delete data[item];\n        }\n    }\n};\n\nconst initData = (cur, pre, root = false) =&gt; {\n    if (cur === pre) return;\n    const curType = getType(cur);\n    const preType = getType(pre);\n    if (curType !== preType) return;\n    if (curType === ARRAY_TYPE &amp;&amp; cur.length &gt;= pre.length) {\n        for (let i = 0; i &lt; pre.length; i++) {\n            initData(cur[i], pre[i]);\n        }\n    } else if (curType === OBJECT_TYPE &amp;&amp; Object.keys(cur).length &gt;= Object.keys(pre).length) {\n        for (const key in pre) {\n            if (!root &amp;&amp; cur[key] === undefined) {\n                cur[key] = null;\n            } else {\n                initData(cur[key], pre[key]);\n            }\n        }\n    }\n};\n\nconst doDiff = (cur, pre, target, path = \'\', root = false) =&gt; {\n    if (cur === pre) return;\n    const curRootType = getType(cur);\n    const preRootType = getType(pre);\n    if (curRootType === ARRAY_TYPE &amp;&amp; preRootType === curRootType &amp;&amp; cur.length &gt;= pre.length) {\n        for (let i = 0; i &lt; cur.length; i++) {\n            doDiff(cur[i], pre[i], target, `${path}[${i}]`);\n        }\n        return;\n    }\n    if (\n        curRootType === OBJECT_TYPE &amp;&amp;\n        preRootType === curRootType &amp;&amp;\n        (root || Object.keys(cur).length &gt;= Object.keys(pre).length)\n    ) {\n        const keys = Object.keys(cur);\n        for (const key of keys) {\n            const curVal = cur[key];\n            const preVal = pre[key];\n            const curType = getType(curVal);\n            const preType = getType(preVal);\n            if (curVal === preVal) continue;\n            if (curType === ARRAY_TYPE &amp;&amp; preType === curType &amp;&amp; curVal.length &gt;= preVal.length) {\n                for (let i = 0; i &lt; curVal.length; i++) {\n                    doDiff(curVal[i], preVal[i], target, `${path ? `${path}.` : \'\'}${key}[${i}]`);\n                }\n                continue;\n            }\n            if (\n                curType === OBJECT_TYPE &amp;&amp;\n                preType === curType &amp;&amp;\n                Object.keys(curVal).length &gt;= Object.keys(preVal).length\n            ) {\n                for (const sKey in curVal) {\n                    doDiff(curVal[sKey], preVal[sKey], target, `${path ? `${path}.` : \'\'}${key}.${sKey}`);\n                }\n                continue;\n            }\n            target[`${path ? `${path}.` : \'\'}${key}`] = curVal;\n        }\n        return;\n    }\n    target[path] = cur;\n};\n\nexport function diffData(data, prevData) {\n    const target = {};\n    initPath(data);\n    initData(data, prevData, true);\n    doDiff(data, prevData, target, \'\', true);\n    return target;\n}\n</code></pre>\n<h5 id="reconcile">reconcile</h5>\n<pre><code class="js language-js">export function noop() {}\n\n\nexport function shape(source, target) {\n    const accumulator = {};\n    const keys = Object.keys(target);\n\n    for (const key of keys) {\n        accumulator[key] = source[key];\n    }\n\n    return accumulator;\n}\n\nfunction _basePath(path) {\n    if (Array.isArray(path)) return path;\n    return path.replace(/\\[/g, \'.\').replace(/\\]/g, \'\').split(\'.\')\n}\n\nfunction set(object, path, value) {\n    if (typeof object !== \'object\') return object;\n\n    _basePath(path).reduce((o, k, i, _) =&gt; {\n        if (i === _.length - 1) {\n            o[k] = value\n            return null\n        } else if (k in o) {\n            return o[k]\n        } else {\n            o[k] = /^[0-9]{1,}$/.test(_[i + 1]) ? [] : {}\n            return o[k]\n        }\n    }, object)\n\n    return object;\n}\n\nexport function syncData(ctx, data) {\n    Object.keys(data).forEach(key =&gt; {\n        set(ctx.data, key, data[key])\n    })\n}\n\nfunction getTick() {\n    return fn =&gt; setTimeout(fn, 0);\n}\n\nexport const tick = getTick();\n\nexport class Stream {\n    data: Array&lt;unknown&gt; = [];\n    listeners = {};\n    hasEnd: boolean = false;\n\n    constructor () {\n        this.data = [];\n        this.listeners = {};\n        this.hasEnd = false;\n    }\n\n    on(key, callback) {\n        if (typeof callback !== \'function\') return;\n\n        this.listeners[key] = this.listeners[key] || [];\n        this.listeners[key].push(callback);\n    }\n\n    emit(key, ...args) {\n        const callbacks = this.listeners[key] || [];\n\n        for (const cb of callbacks) {\n            cb(...args);\n        }\n    }\n\n    add(data) {\n        this.data.push(data);\n        this.emit(\'data\', data)\n    }\n\n    end() {\n        if (this.hasEnd) return;\n        this.hasEnd = true;\n        this.emit(\'end\', this.data);\n    }\n\n    getData() {\n        if (!this.data.length) return null;\n\n        const ret = Object.create(null);\n\n        while (this.data.length &gt; 0) {\n            const unit = this.data.shift();\n            Object.assign(ret, unit);\n        }\n\n        return ret;\n    }\n\n    destroy() {\n        this.data = [];\n        this.listeners = {};\n        this.hasEnd = false;\n    }\n}\n\n\nexport function getReconciler() {\n    let onLoadTime = 0;\n    let mounted = null;\n    let perf = null;\n    let ctx = null;\n    let workingDiffs = [];\n    let workingCallbacks = [];\n    let pendingUpdate = false;\n    let pendingFlush = false;\n    let beforeMountedSetData = [];\n    let beforeMountedCallback = [];\n\n    let stream = null;\n\n    function enqueueUpdate(data) {\n        workingDiffs.push(data);\n\n        if (!pendingUpdate) {\n            performUpdate();\n        }\n    }\n\n    function enqueueUpdateCallback(callback) {\n        workingCallbacks.push(() =&gt; {\n            callback();\n        });\n    }\n\n    function performUpdate() {\n        pendingUpdate = true;\n\n        const render = () =&gt; {\n            perf &amp;&amp; perf.start();\n            const data = Object.create(null);\n\n            while (workingDiffs.length &gt; 0) {\n                const diff = workingDiffs.shift();\n                Object.assign(data, diff);\n            }\n\n            pendingUpdate = false;\n            perf &amp;&amp; perf.record(data);\n\n            ctx &amp;&amp; ctx.originalSetData(data, () =&gt; {\n                perf &amp;&amp; perf.stop();\n                if (!pendingFlush) {\n                    flushUpdateCallback();\n                }\n            });\n        }\n\n        tick(render);\n    }\n\n    function flushUpdateCallback() {\n        pendingFlush = true;\n        const cbs = workingCallbacks.slice(0);\n        workingCallbacks.length = 0;\n        for (const cb of cbs) {\n            cb();\n        }\n        pendingFlush = false;\n    }\n\n    function update(this: any, data, callback = noop) {\n        if (!ctx) ctx = this;\n        if (!perf) perf = getPerf({ ctx: this, onLoadTime, name: this.tag || this.data.tag || \'unknown\' });\n        if (mounted === null) {\n            syncData(ctx, data)\n            stream?.add(data);\n            beforeMountedCallback.push(callback);\n            return;\n        }\n        if (mounted === false) return; // 已卸载\n\n        stream?.end();\n        perf?.count();\n\n        const previous = shape(ctx.data, data);\n        const diff = diffData(data, previous);\n        // 微信行为：同步更新数据\n        syncData(ctx, data);\n\n        if (!Object.keys(diff).length) return;\n\n        enqueueUpdate(diff);\n        enqueueUpdateCallback(callback);\n    }\n\n    function flushBeforeMountedSetDataCallbacks() {\n        const cbs = beforeMountedCallback.slice(0);\n        beforeMountedCallback.length = 0;\n        for (const cb of cbs) {\n            cb();\n        }\n    }\n\n    function init(this: any) {\n        onLoadTime = Date.now();\n        this.originalSetData = this.setData.bind(this);\n        this.setData = update.bind(this);\n        stream = new Stream();\n        stream?.on(\'end\', () =&gt; {\n            const data = stream.getData();\n            if (!data) return;\n            this.originalSetData(data, flushBeforeMountedSetDataCallbacks);\n        })\n    }\n\n    function mount(this: any) {\n        mounted = true;\n        stream?.end();\n    }\n\n    function unmount() {\n        stream = null;\n        mounted = false;\n        perf = null;\n        ctx = null;\n        workingDiffs = [];\n        workingCallbacks = [];\n        pendingUpdate = false;\n        pendingFlush = false;\n        beforeMountedSetData = [];\n        beforeMountedCallback= [];\n    }\n\n    return { init, mount, unmount };\n}\n</code></pre>\n<h5 id="wrap">wrap</h5>\n<pre><code class="js language-js">export function reconcileComponent(component) {\n    component.lifetimes = component.lifetimes || {};\n    const originalCreated = component.created || component.lifetimes.created || noop;\n    const originalDetached = component.detached || component.lifetimes.detached || noop;\n\n    let reconciler = null;\n\n    function created(this: any, ...args) {\n        reconciler = getReconciler();\n        reconciler.init.apply(this, args);\n        reconciler.mount.apply(this, args);\n        originalCreated.apply(this, args);\n    }\n\n    function detached(this: any, ...args) {\n        reconciler.unmount.apply(this, args);\n        originalDetached.apply(this, args);\n    }\n\n    component.created = created;\n    component.lifetimes.created = created;\n    component.detached = detached;\n    component.lifetimes.detached = detached;\n\n    return component;\n}\n\nexport function reconcilePage(page) {\n    const originalOnLoad = page.onLoad || noop;\n    const originalOnReady = page.onReady || noop;\n    const originalOnUnload = page.onUnload || noop;\n\n    let reconciler = null;\n\n    page.onLoad = function (...args) {\n        reconciler = getReconciler();\n        reconciler.init.apply(this, args);\n        originalOnLoad.apply(this, args);\n    };\n\n    page.onReady = function (...args) {\n        originalOnReady.apply(this, args);\n        reconciler.mount.apply(this, args);\n    };\n\n    page.onUnload = function (...args) {\n        reconciler.unmount.apply(this, args);\n        originalOnUnload.apply(this, args);\n    };\n\n    return page;\n}\n</code></pre>\n<h2 id="总结">总结</h2>\n<p>小程序的首屏性能治理涉及到各阶段各个方面，需要各个监控埋点，分析优化。</p>\n<h3 id="1-启动优化">1. 启动优化</h3>\n<ul>\n<li>减少发版频次、控制代码包体积</li>\n</ul>\n<h3 id="2-渲染优化">2. 渲染优化</h3>\n<ul>\n<li>延迟执行非首屏逻辑、延迟加载非首屏组件</li>\n<li>接口请求：接口合并、数据精简、域名收敛、预加载</li>\n<li>数据缓存</li>\n<li>setData：合并 setData 减少次数、控制数据量大小、数据 diff 精准更新</li>\n<li>WXML：控制节点数、层级</li>\n<li>图片：压缩裁剪、懒加载、选择合适的格式（webp）、图片缓存</li>\n</ul>',
          toc: '[{"level":"2","id":"首屏时间定义","text":"首屏时间定义"},{"level":"2","id":"优化治理","text":"优化治理"},{"level":"3","id":"小程序启动阶段","text":"小程序启动阶段"},{"level":"3","id":"首屏渲染阶段","text":"首屏渲染阶段"},{"level":"4","id":"1-初始执行优化","text":"1. 初始执行优化"},{"level":"4","id":"2-数据加载优化","text":"2. 数据加载优化"},{"level":"5","id":"1-缓存数据读取","text":"1. 缓存数据读取"},{"level":"5","id":"2-接口请求优化","text":"2. 接口请求优化"},{"level":"5","id":"3-接口耗时优化","text":"3. 接口耗时优化"},{"level":"4","id":"3-页面渲染优化","text":"3. 页面渲染优化"},{"level":"5","id":"1-setdata","text":"1. setData"},{"level":"5","id":"2-wxml","text":"2. WXML"},{"level":"5","id":"3-图片","text":"3. 图片"},{"level":"2","id":"技术手段","text":"技术手段"},{"level":"3","id":"setdata-的优化","text":"setData 的优化"},{"level":"4","id":"调度手段","text":"调度手段"},{"level":"4","id":"编码实现","text":"编码实现"},{"level":"5","id":"diff","text":"diff"},{"level":"5","id":"reconcile","text":"reconcile"},{"level":"5","id":"wrap","text":"wrap"},{"level":"2","id":"总结","text":"总结"},{"level":"3","id":"1-启动优化","text":"1. 启动优化"},{"level":"3","id":"2-渲染优化","text":"2. 渲染优化"}]',
          status: 'publish',
          views: 3583,
          likes: 325,
          isRecommended: true,
          needPassword: false,
          isCommentable: false,
          publishAt: '2022-04-02T09:01:35.000Z',
          createAt: '2021-12-08T19:37:45.076Z',
          updateAt: '2022-05-10T05:35:31.000Z',
        },
      ],
    },
  });
}
